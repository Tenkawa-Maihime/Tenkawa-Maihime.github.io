---
layout:     post
title:      "项目架构演进"
date:       2018-06-17
author:     "Hime"
header-img: "img/article-bg.JPG"
catalog: true
tags:
    - 架构
---

施工中。。。

在项目刚刚开始的时候，采用的是典型的三层架构。
![](/img/evolution/ppt1.JPG)

由于项目的需求，整个APP并不需要持久化储存。因此各个manager除了逻辑以外还储存着临时数据。
Manager之间会相互调用，以及访问各自的数据。
![](/img/evolution/ppt2.JPG)

随着业务内容的不断增加，Manager之间的关系也会变得越来越复杂，数据的相互调用很容易发生错误。
因此需要将Manager中的业务逻辑与数据分离，参考Redux的思想，我们进行了改进。

#### 改进
![](/img/evolution/ppt3.JPG)
我们将数据抽出封装成Store，Store中包含着一个树状的数据结构State，我们将UI层与其进行绑定。当State发生改变时，UI层就会做出相对应的改变。
但是随着业务复杂度的上升，State作为一个庞大的树确实难以维护，当树中的某个数据发生变化时，整棵树都会刷新，这降低了性能以及提高了Dubug的难度。  

因此我们进一步的将Store进行拆分，让他们相对独立，不会因为一个数据的变化而刷新其他不相关的UI。
这在性能上得到了一定的提高，但是Debug仍然有难度，因为UI层只知道数据变化了，而做出相对应的变化，但是不知道数据为什么变化。当UI与我们的预期不符时，我们很难找到是什么原因改变了这个数据源。  

这也就是数据驱动的特性，如果我们改用事件驱动的话，就能很轻松的知道数据为什么发生变化，Debug就会相对简单。
我们再一次进行重构，这次采用事件驱动, 即当数据源发生变化时，我们发出通知，告诉UI层让其主动去拉取最新的数据。 

![](/img/evolution/ppt4.JPG)
将与Manager同级的Store下移为仓库层，这使得我们的流经过Manger时不会分叉为UI和Store，每当我们的请求返回结果时将数据存入其中，请求流抵达UI层时，UI层主动向底层仓库层获取数据。

#### 模块化

我们采用Cocoapods以及Framework来进行模块化，对于高度复用以及与业务逻辑无关的部分将其封装成私有pod（如网络请求模块），其余的采用Framework添加到项目中。  

这里的Manager将封装成FrameWork，它们之间相互独立，UI层依赖于Manager，如果Manager需要依赖UI层的某些东西或者Manager之间相互依赖，可以定义接口，通过它来进行依赖倒置。
![](/img/evolution/ppt5.JPG)

模块化的比较适合多人团队，每个人负责特定的模块。初期搭建会比较繁琐，但到了后期多项目时会非常方便。 

#### React Native
目前看来，混编是大趋势。  
因此我们的另外一个项目采用了React Native。  
